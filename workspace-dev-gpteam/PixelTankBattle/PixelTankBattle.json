{
    "refine_requirements": "\n# Single-level 2D pixel-art styled tank battle game with destructible terrain and power-ups\n\n```\n1. Start with an introduction to controls and the objective: destroy both enemy tanks.\n2. Player starts at a predetermined location within a destructible maze.\n3. Navigate the maze, locate and destroy two enemy tanks while avoiding their attacks.\n4. Control scheme allows movement in all four cardinal directions and independent turret rotation for aiming; continuous firing without ammunition or reloading.\n5. Scoring based on enemy tanks destroyed, level completion speed, and hit avoidance.\n6. Game ends when the player's tank is destroyed or both enemy tanks are defeated; option to restart.\n7. Shoot projectiles to destroy enemy tanks and terrain obstacles; enemy tanks can do the same.\n8. Terrain obstacles in the maze can be destroyed, altering the maze layout during gameplay.\n9. Two enemy tanks patrol the maze and will aim and fire at the player upon visual contact.\n10. A power-up appears in the maze after the first enemy tank is destroyed, offering enhancements like increased speed, a temporary shield, or a more powerful shot.\n11. Visual feedback for firing, hits, tank and obstacle destruction, power-up acquisition, and other actions.\n```\n",
    "developed_code": "<PROJECT_NAME_START>PixelTankBattle<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport random\nimport math\n\n# Constants\nSCREEN_WIDTH = 800\nSCREEN_HEIGHT = 600\nTANK_SIZE = 40\nTURRET_LENGTH = 25\nPROJECTILE_RADIUS = 4\nOBSTACLE_SIZE = 40\nPOWER_UP_SIZE = 30\nENEMY_TANK_COUNT = 2\nMAZE_ROWS = 10\nMAZE_COLS = 15\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nYELLOW = (255, 255, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\npygame.display.set_caption('Pixel Tank Battle')\nclock = pygame.time.Clock()\n\n# Game variables\nplayer_position = (100, 100)\nplayer_angle = 0\nplayer_turret_angle = 0\nplayer_speed = 2\nplayer_rotation_speed = 2\nprojectiles = []\nenemies = []\nobstacles = []\npower_ups = []\nscore = 0\ngame_over = False\npower_up_active = False\npower_up_type = None\npower_up_timer = 0\n\n# Functions\ndef draw_tank(position, angle, turret_angle, color):\n    # Draw tank body\n    tank_rect = pygame.Rect(0, 0, TANK_SIZE, TANK_SIZE)\n    tank_rect.center = position\n    pygame.draw.rect(screen, color, tank_rect)\n\n    # Draw turret\n    end_x = position[0] + math.cos(math.radians(turret_angle)) * TURRET_LENGTH\n    end_y = position[1] + math.sin(math.radians(turret_angle)) * TURRET_LENGTH\n    pygame.draw.line(screen, color, position, (end_x, end_y), 4)\n\ndef move_tank(position, angle, speed):\n    new_x = position[0] + math.cos(math.radians(angle)) * speed\n    new_y = position[1] + math.sin(math.radians(angle)) * speed\n    return new_x, new_y\n\ndef rotate_tank(angle, rotation_speed, direction):\n    return angle + (rotation_speed * direction)\n\ndef fire_projectile(position, angle):\n    end_x = position[0] + math.cos(math.radians(angle)) * (TURRET_LENGTH + PROJECTILE_RADIUS)\n    end_y = position[1] + math.sin(math.radians(angle)) * (TURRET_LENGTH + PROJECTILE_RADIUS)\n    projectiles.append({'position': (end_x, end_y), 'angle': angle})\n\ndef draw_projectiles():\n    for projectile in projectiles:\n        pygame.draw.circle(screen, RED, projectile['position'], PROJECTILE_RADIUS)\n\ndef move_projectiles():\n    for projectile in projectiles:\n        new_x = projectile['position'][0] + math.cos(math.radians(projectile['angle'])) * 5\n        new_y = projectile['position'][1] + math.sin(math.radians(projectile['angle'])) * 5\n        projectile['position'] = (new_x, new_y)\n\ndef generate_maze():\n    for row in range(MAZE_ROWS):\n        for col in range(MAZE_COLS):\n            if random.choice([True, False]):\n                obstacles.append(pygame.Rect(col * OBSTACLE_SIZE, row * OBSTACLE_SIZE, OBSTACLE_SIZE, OBSTACLE_SIZE))\n\ndef draw_maze():\n    for obstacle in obstacles:\n        pygame.draw.rect(screen, GREEN, obstacle)\n\ndef spawn_enemies():\n    for _ in range(ENEMY_TANK_COUNT):\n        x = random.randint(0, SCREEN_WIDTH - TANK_SIZE)\n        y = random.randint(0, SCREEN_HEIGHT - TANK_SIZE)\n        enemies.append({'position': (x, y), 'angle': 0, 'turret_angle': random.randint(0, 360)})\n\ndef draw_enemies():\n    for enemy in enemies:\n        draw_tank(enemy['position'], enemy['angle'], enemy['turret_angle'], BLUE)\n\ndef spawn_power_up():\n    x = random.randint(0, SCREEN_WIDTH - POWER_UP_SIZE)\n    y = random.randint(0, SCREEN_HEIGHT - POWER_UP_SIZE)\n    power_ups.append({'position': (x, y), 'type': random.choice(['speed', 'shield', 'power'])})\n\ndef draw_power_ups():\n    for power_up in power_ups:\n        if power_up['type'] == 'speed':\n            color = YELLOW\n        elif power_up['type'] == 'shield':\n            color = WHITE\n        else:  # 'power'\n            color = RED\n        pygame.draw.rect(screen, color, pygame.Rect(power_up['position'][0], power_up['position'][1], POWER_UP_SIZE, POWER_UP_SIZE))\n\ndef check_collisions():\n    global game_over, score, power_up_active, power_up_type, power_up_timer\n    player_rect = pygame.Rect(player_position[0] - TANK_SIZE / 2, player_position[1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n    \n    # Check projectile collisions with obstacles\n    for projectile in projectiles[:]:\n        projectile_rect = pygame.Rect(projectile['position'][0] - PROJECTILE_RADIUS, projectile['position'][1] - PROJECTILE_RADIUS, PROJECTILE_RADIUS * 2, PROJECTILE_RADIUS * 2)\n        for obstacle in obstacles[:]:\n            if projectile_rect.colliderect(obstacle):\n                obstacles.remove(obstacle)\n                projectiles.remove(projectile)\n                break\n    \n    # Check projectile collisions with enemies\n    for projectile in projectiles[:]:\n        projectile_rect = pygame.Rect(projectile['position'][0] - PROJECTILE_RADIUS, projectile['position'][1] - PROJECTILE_RADIUS, PROJECTILE_RADIUS * 2, PROJECTILE_RADIUS * 2)\n        for enemy in enemies[:]:\n            enemy_rect = pygame.Rect(enemy['position'][0] - TANK_SIZE / 2, enemy['position'][1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n            if projectile_rect.colliderect(enemy_rect):\n                enemies.remove(enemy)\n                projectiles.remove(projectile)\n                score += 100\n                if len(enemies) == ENEMY_TANK_COUNT - 1:\n                    spawn_power_up()\n                break\n    \n    # Check player collisions with power-ups\n    for power_up in power_ups[:]:\n        power_up_rect = pygame.Rect(power_up['position'][0], power_up['position'][1], POWER_UP_SIZE, POWER_UP_SIZE)\n        if player_rect.colliderect(power_up_rect):\n            power_up_active = True\n            power_up_type = power_up['type']\n            power_up_timer = pygame.time.get_ticks()\n            power_ups.remove(power_up)\n    \n    # Check player collisions with enemies\n    for enemy in enemies:\n        enemy_rect = pygame.Rect(enemy['position'][0] - TANK_SIZE / 2, enemy['position'][1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n        if player_rect.colliderect(enemy_rect):\n            game_over = True\n    \n    # Check if game is over\n    if len(enemies) == 0:\n        game_over = True\n\ndef apply_power_up():\n    global player_speed, power_up_active, power_up_timer\n    if power_up_active:\n        current_time = pygame.time.get_ticks()\n        if power_up_type == 'speed' and current_time - power_up_timer < 5000:\n            player_speed = 4\n        elif power_up_type == 'shield' and current_time - power_up_timer < 5000:\n            # Implement shield effect\n            pass\n        elif power_up_type == 'power' and current_time - power_up_timer < 5000:\n            # Implement power shot effect\n            pass\n        else:\n            power_up_active = False\n            player_speed = 2\n\ndef game_intro():\n    intro = True\n    while intro:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                quit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_RETURN:\n                    intro = False\n        \n        screen.fill(BLACK)\n        font = pygame.font.Font(None, 36)\n        text = font.render('Welcome to Pixel Tank Battle!', True, WHITE)\n        text_rect = text.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 50))\n        screen.blit(text, text_rect)\n        \n        instructions = font.render('Use arrow keys to move, space to fire.', True, WHITE)\n        instructions_rect = instructions.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))\n        screen.blit(instructions, instructions_rect)\n        \n        start_msg = font.render('Press Enter to start', True, WHITE)\n        start_msg_rect = start_msg.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 50))\n        screen.blit(start_msg, start_msg_rect)\n        \n        pygame.display.update()\n        clock.tick(15)\n\ndef game_loop():\n    global player_position, player_angle, player_turret_angle, game_over, score\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n        \n        keys = pygame.key.get_pressed()\n        if keys[pygame.K_LEFT]:\n            player_angle = rotate_tank(player_angle, player_rotation_speed, -1)\n        if keys[pygame.K_RIGHT]:\n            player_angle = rotate_tank(player_angle, player_rotation_speed, 1)\n        if keys[pygame.K_UP]:\n            player_position = move_tank(player_position, player_angle, player_speed)\n        if keys[pygame.K_DOWN]:\n            player_position = move_tank(player_position, player_angle, -player_speed)\n        if keys[pygame.K_a]:\n            player_turret_angle -= 5\n        if keys[pygame.K_d]:\n            player_turret_angle += 5\n        if keys[pygame.K_SPACE]:\n            fire_projectile(player_position, player_turret_angle)\n        \n        screen.fill(BLACK)\n        draw_maze()\n        draw_power_ups()\n        draw_tank(player_position, player_angle, player_turret_angle, GREEN)\n        draw_enemies()\n        move_projectiles()\n        draw_projectiles()\n        check_collisions()\n        apply_power_up()\n        \n        if game_over:\n            font = pygame.font.Font(None, 74)\n            text = font.render('Game Over', True, RED)\n            text_rect = text.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))\n            screen.blit(text, text_rect)\n        \n        pygame.display.flip()\n        clock.tick(FPS)\n    \n    pygame.quit()\n    quit()\n\n# Main execution\nif __name__ == '__main__':\n    game_intro()\n    generate_maze()\n    spawn_enemies()\n    game_loop()\n```\n<FILE_END>",
    "finalized_code": "<PROJECT_NAME_START>PixelTankBattle<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport random\nimport math\n\n# Constants\nSCREEN_WIDTH = 800\nSCREEN_HEIGHT = 600\nTANK_SIZE = 40\nTURRET_LENGTH = 25\nPROJECTILE_RADIUS = 4\nOBSTACLE_SIZE = 40\nPOWER_UP_SIZE = 30\nENEMY_TANK_COUNT = 2\nMAZE_ROWS = 10\nMAZE_COLS = 15\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nYELLOW = (255, 255, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\npygame.display.set_caption('Pixel Tank Battle')\nclock = pygame.time.Clock()\n\n# Game variables\nplayer_position = [100, 100]  # Changed to list to allow item assignment\nplayer_angle = 0\nplayer_turret_angle = 0\nplayer_speed = 2\nplayer_rotation_speed = 2\nprojectiles = []\nenemies = []\nobstacles = []\npower_ups = []\nscore = 0\ngame_over = False\npower_up_active = False\npower_up_type = None\npower_up_timer = 0\n\n# Functions\ndef draw_tank(position, angle, turret_angle, color):\n    # Draw tank body\n    tank_rect = pygame.Rect(0, 0, TANK_SIZE, TANK_SIZE)\n    tank_rect.center = position\n    pygame.draw.rect(screen, color, tank_rect)\n\n    # Draw turret\n    end_x = position[0] + math.cos(math.radians(turret_angle)) * TURRET_LENGTH\n    end_y = position[1] + math.sin(math.radians(turret_angle)) * TURRET_LENGTH\n    pygame.draw.line(screen, color, position, (end_x, end_y), 4)\n\ndef move_tank(position, angle, speed):\n    new_x = position[0] + math.cos(math.radians(angle)) * speed\n    new_y = position[1] + math.sin(math.radians(angle)) * speed\n    return [new_x, new_y]  # Changed to list to allow item assignment\n\ndef rotate_tank(angle, rotation_speed, direction):\n    return angle + (rotation_speed * direction)\n\ndef fire_projectile(position, angle):\n    end_x = position[0] + math.cos(math.radians(angle)) * (TURRET_LENGTH + PROJECTILE_RADIUS)\n    end_y = position[1] + math.sin(math.radians(angle)) * (TURRET_LENGTH + PROJECTILE_RADIUS)\n    projectiles.append({'position': [end_x, end_y], 'angle': angle})  # Changed to list to allow item assignment\n\ndef draw_projectiles():\n    for projectile in projectiles:\n        pygame.draw.circle(screen, RED, projectile['position'], PROJECTILE_RADIUS)\n\ndef move_projectiles():\n    for projectile in projectiles:\n        new_x = projectile['position'][0] + math.cos(math.radians(projectile['angle'])) * 5\n        new_y = projectile['position'][1] + math.sin(math.radians(projectile['angle'])) * 5\n        projectile['position'] = [new_x, new_y]  # Changed to list to allow item assignment\n\ndef generate_maze():\n    for row in range(MAZE_ROWS):\n        for col in range(MAZE_COLS):\n            if random.choice([True, False]):\n                obstacles.append(pygame.Rect(col * OBSTACLE_SIZE, row * OBSTACLE_SIZE, OBSTACLE_SIZE, OBSTACLE_SIZE))\n\ndef draw_maze():\n    for obstacle in obstacles:\n        pygame.draw.rect(screen, GREEN, obstacle)\n\ndef spawn_enemies():\n    while len(enemies) < ENEMY_TANK_COUNT:\n        x = random.randint(0, SCREEN_WIDTH - TANK_SIZE)\n        y = random.randint(0, SCREEN_HEIGHT - TANK_SIZE)\n        enemy_rect = pygame.Rect(x, y, TANK_SIZE, TANK_SIZE)\n        if not any(enemy_rect.colliderect(obstacle) for obstacle in obstacles):\n            enemies.append({'position': [x, y], 'angle': 0, 'turret_angle': random.randint(0, 360)})  # Changed to list to allow item assignment\n\ndef draw_enemies():\n    for enemy in enemies:\n        draw_tank(enemy['position'], enemy['angle'], enemy['turret_angle'], BLUE)\n\ndef spawn_power_up():\n    valid_position = False\n    while not valid_position:\n        x = random.randint(0, SCREEN_WIDTH - POWER_UP_SIZE)\n        y = random.randint(0, SCREEN_HEIGHT - POWER_UP_SIZE)\n        power_up_rect = pygame.Rect(x, y, POWER_UP_SIZE, POWER_UP_SIZE)\n        if not any(power_up_rect.colliderect(obstacle) for obstacle in obstacles):\n            valid_position = True\n            power_ups.append({'position': [x, y], 'type': random.choice(['speed', 'shield', 'power'])})  # Changed to list to allow item assignment\n\ndef draw_power_ups():\n    for power_up in power_ups:\n        if power_up['type'] == 'speed':\n            color = YELLOW\n        elif power_up['type'] == 'shield':\n            color = WHITE\n        else:  # 'power'\n            color = RED\n        pygame.draw.rect(screen, color, pygame.Rect(power_up['position'][0], power_up['position'][1], POWER_UP_SIZE, POWER_UP_SIZE))\n\ndef check_collisions():\n    global game_over, score, power_up_active, power_up_type, power_up_timer\n    player_rect = pygame.Rect(player_position[0] - TANK_SIZE / 2, player_position[1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n    \n    # Check projectile collisions with obstacles\n    for projectile in projectiles[:]:\n        projectile_rect = pygame.Rect(projectile['position'][0] - PROJECTILE_RADIUS, projectile['position'][1] - PROJECTILE_RADIUS, PROJECTILE_RADIUS * 2, PROJECTILE_RADIUS * 2)\n        for obstacle in obstacles[:]:\n            if projectile_rect.colliderect(obstacle):\n                obstacles.remove(obstacle)\n                projectiles.remove(projectile)\n                break\n    \n    # Check projectile collisions with enemies\n    for projectile in projectiles[:]:\n        projectile_rect = pygame.Rect(projectile['position'][0] - PROJECTILE_RADIUS, projectile['position'][1] - PROJECTILE_RADIUS, PROJECTILE_RADIUS * 2, PROJECTILE_RADIUS * 2)\n        for enemy in enemies[:]:\n            enemy_rect = pygame.Rect(enemy['position'][0] - TANK_SIZE / 2, enemy['position'][1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n            if projectile_rect.colliderect(enemy_rect):\n                enemies.remove(enemy)\n                projectiles.remove(projectile)\n                score += 100\n                if len(enemies) == ENEMY_TANK_COUNT - 1:\n                    spawn_power_up()\n                break\n    \n    # Check player collisions with power-ups\n    for power_up in power_ups[:]:\n        power_up_rect = pygame.Rect(power_up['position'][0], power_up['position'][1], POWER_UP_SIZE, POWER_UP_SIZE)\n        if player_rect.colliderect(power_up_rect):\n            power_up_active = True\n            power_up_type = power_up['type']\n            power_up_timer = pygame.time.get_ticks()\n            power_ups.remove(power_up)\n    \n    # Check player collisions with enemies\n    for enemy in enemies:\n        enemy_rect = pygame.Rect(enemy['position'][0] - TANK_SIZE / 2, enemy['position'][1] - TANK_SIZE / 2, TANK_SIZE, TANK_SIZE)\n        if player_rect.colliderect(enemy_rect):\n            game_over = True\n    \n    # Check if game is over\n    if len(enemies) == 0:\n        game_over = True\n\ndef apply_power_up():\n    global player_speed, power_up_active, power_up_timer\n    if power_up_active:\n        current_time = pygame.time.get_ticks()\n        if power_up_type == 'speed' and current_time - power_up_timer < 5000:\n            player_speed = 4\n        elif power_up_type == 'shield' and current_time - power_up_timer < 5000:\n            # Implement shield effect\n            pass\n        elif power_up_type == 'power' and current_time - power_up_timer < 5000:\n            # Implement power shot effect\n            pass\n        else:\n            power_up_active = False\n            player_speed = 2\n\ndef game_intro():\n    intro = True\n    while intro:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                quit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_RETURN:\n                    intro = False\n        \n        screen.fill(BLACK)\n        font = pygame.font.Font(None, 36)\n        text = font.render('Welcome to Pixel Tank Battle!', True, WHITE)\n        text_rect = text.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 50))\n        screen.blit(text, text_rect)\n        \n        instructions = font.render('Use arrow keys to move, space to fire.', True, WHITE)\n        instructions_rect = instructions.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))\n        screen.blit(instructions, instructions_rect)\n        \n        start_msg = font.render('Press Enter to start', True, WHITE)\n        start_msg_rect = start_msg.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 50))\n        screen.blit(start_msg, start_msg_rect)\n        \n        pygame.display.update()\n        clock.tick(15)\n\ndef game_loop():\n    global player_position, player_angle, player_turret_angle, game_over, score\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n        \n        keys = pygame.key.get_pressed()\n        if keys[pygame.K_LEFT]:\n            player_angle = rotate_tank(player_angle, player_rotation_speed, -1)\n        if keys[pygame.K_RIGHT]:\n            player_angle = rotate_tank(player_angle, player_rotation_speed, 1)\n        if keys[pygame.K_UP]:\n            player_position = move_tank(player_position, player_angle, player_speed)\n        if keys[pygame.K_DOWN]:\n            player_position = move_tank(player_position, player_angle, -player_speed)\n        if keys[pygame.K_a]:\n            player_turret_angle -= 5\n        if keys[pygame.K_d]:\n            player_turret_angle += 5\n        if keys[pygame.K_SPACE]:\n            fire_projectile(player_position, player_turret_angle)\n        \n        screen.fill(BLACK)\n        draw_maze()\n        draw_power_ups()\n        draw_tank(player_position, player_angle, player_turret_angle, GREEN)\n        draw_enemies()\n        move_projectiles()\n        draw_projectiles()\n        check_collisions()\n        apply_power_up()\n        \n        if game_over:\n            font = pygame.font.Font(None, 74)\n            text = font.render('Game Over', True, RED)\n            text_rect = text.get_rect(center=(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))\n            screen.blit(text, text_rect)\n        \n        pygame.display.flip()\n        clock.tick(FPS)\n    \n    pygame.quit()\n    quit()\n\n# Main execution\nif __name__ == '__main__':\n    game_intro()\n    generate_maze()\n    spawn_enemies()\n    game_loop()\n```\n<FILE_END>"
}