{
    "refine_requirements": "\n# Classic 2048 Puzzle Game\n```\n1. The game initiates with two '2' tiles randomly placed on a 4x4 graphic board.\n2. Players use the arrow keys (up, down, left, right) to slide all tiles in the pressed direction.\n3. When two tiles with the same number touch, they merge into one tile with their sum.\n4. After every swipe, a new tile (either '2' or '4') appears in a random empty spot on the grid.\n5. The objective is to combine tiles to reach and surpass the 2048 tile.\n6. The score is calculated by adding the values of merged tiles throughout the gameplay.\n7. The game ends when no more moves are possible, and the grid is full.\n8. Players can restart the game at any time, which resets the grid and score.\n9. The game continues after the 2048 tile is reached, allowing players to achieve higher scores and create tiles with larger numbers.\n```\n",
    "developed_code": "<PROJECT_NAME_START>Py2048Game<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport tkinter as tk\nimport random\nimport numpy as np\n\nclass Game2048:\n    def __init__(self, root):\n        self.root = root\n        self.grid = np.zeros((4, 4), dtype=int)\n        self.score = 0\n        self.tile_colors = {\n            0: \"#9e948a\",\n            2: \"#eee4da\",\n            4: \"#ede0c8\",\n            8: \"#f2b179\",\n            16: \"#f59563\",\n            32: \"#f67c5f\",\n            64: \"#f65e3b\",\n            128: \"#edcf72\",\n            256: \"#edcc61\",\n            512: \"#edc850\",\n            1024: \"#edc53f\",\n            2048: \"#edc22e\",\n        }\n        self.init_ui()\n        self.start_game()\n\n    def init_ui(self):\n        self.root.title('2048 Game')\n        self.root.resizable(False, False)\n        self.board_frame = tk.Frame(self.root, bg='azure3')\n        self.board_frame.grid()\n        self.tiles = {}\n        for i in range(4):\n            for j in range(4):\n                tile = tk.Label(self.board_frame, text='', bg=self.tile_colors[0], font=('Helvetica', 22, 'bold'), width=4, height=2)\n                tile.grid(row=i, column=j, padx=5, pady=5)\n                self.tiles[(i, j)] = tile\n        self.score_label = tk.Label(self.root, text=f'Score: {self.score}', font=('Helvetica', 18, 'bold'))\n        self.score_label.grid()\n        self.root.bind('<Up>', self.up)\n        self.root.bind('<Down>', self.down)\n        self.root.bind('<Left>', self.left)\n        self.root.bind('<Right>', self.right)\n        self.root.bind('<r>', self.restart_game)\n\n    def start_game(self):\n        self.place_random_tile()\n        self.place_random_tile()\n        self.update_ui()\n\n    def place_random_tile(self):\n        empty_tiles = [(i, j) for i in range(4) for j in range(4) if self.grid[i][j] == 0]\n        if empty_tiles:\n            i, j = random.choice(empty_tiles)\n            self.grid[i][j] = random.choice([2, 4])\n\n    def update_ui(self):\n        for i in range(4):\n            for j in range(4):\n                value = self.grid[i][j]\n                self.tiles[(i, j)].config(text=str(value) if value > 0 else '', bg=self.tile_colors[value])\n        self.score_label.config(text=f'Score: {self.score}')\n\n    def compress(self, grid):\n        new_grid = np.zeros((4, 4), dtype=int)\n        for i in range(4):\n            pos = 0\n            for j in range(4):\n                if grid[i][j] != 0:\n                    new_grid[i][pos] = grid[i][j]\n                    pos += 1\n        return new_grid\n\n    def merge(self, grid):\n        for i in range(4):\n            for j in range(3):\n                if grid[i][j] == grid[i][j + 1] and grid[i][j] != 0:\n                    grid[i][j] *= 2\n                    grid[i][j + 1] = 0\n                    self.score += grid[i][j]\n        return grid\n\n    def reverse(self, grid):\n        new_grid = []\n        for i in range(4):\n            new_grid.append([])\n            for j in range(4):\n                new_grid[i].append(grid[i][3 - j])\n        return np.array(new_grid)\n\n    def transpose(self, grid):\n        return np.transpose(grid)\n\n    def move(self, direction):\n        if direction == 'up':\n            self.grid = self.transpose(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.merge(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.transpose(self.grid)\n        elif direction == 'down':\n            self.grid = self.transpose(self.grid)\n            self.grid = self.reverse(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.merge(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.reverse(self.grid)\n            self.grid = self.transpose(self.grid)\n        elif direction == 'left':\n            self.grid = self.compress(self.grid)\n            self.grid = self.merge(self.grid)\n            self.grid = self.compress(self.grid)\n        elif direction == 'right':\n            self.grid = self.reverse(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.merge(self.grid)\n            self.grid = self.compress(self.grid)\n            self.grid = self.reverse(self.grid)\n        self.place_random_tile()\n        self.update_ui()\n        if self.is_game_over():\n            self.game_over()\n\n    def up(self, event):\n        self.move('up')\n\n    def down(self, event):\n        self.move('down')\n\n    def left(self, event):\n        self.move('left')\n\n    def right(self, event):\n        self.move('right')\n\n    def restart_game(self, event):\n        self.grid = np.zeros((4, 4), dtype=int)\n        self.score = 0\n        self.start_game()\n\n    def is_game_over(self):\n        for i in range(4):\n            for j in range(4):\n                if self.grid[i][j] == 0:\n                    return False\n                if j < 3 and self.grid[i][j] == self.grid[i][j + 1]:\n                    return False\n                if i < 3 and self.grid[i][j] == self.grid[i + 1][j]:\n                    return False\n        return True\n\n    def game_over(self):\n        game_over_frame = tk.Frame(self.root, borderwidth=2, relief='raised')\n        game_over_frame.place(relx=0.5, rely=0.5, anchor='center')\n        tk.Label(game_over_frame, text='Game Over!', font=('Helvetica', 18, 'bold')).pack()\n        tk.Button(game_over_frame, text='Restart', command=lambda: [game_over_frame.destroy(), self.restart_game(None)]).pack()\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    game = Game2048(root)\n    root.mainloop()\n```\n<FILE_END>",
    "finalized_code": null
}