{
    "refine_requirements": "\n# Classic Tetris Game for Desktop\n```\n# Gameplay initialization at a standard speed suitable for adults.\n# Increase falling speed of Tetriminos every 10 seconds for difficulty progression.\n# Focus on high score achievement without a progression or rewards system.\n# Implement keyboard-only controls for moving left, right, rotating, and speeding up Tetriminos.\n# Utilize traditional Tetris scoring based on the number of lines cleared.\n# Game ends when blocks stack to the top of the screen, with no additional ending conditions.\n# Use the standard Tetris block set without special blocks or power-ups.\n# Include a post-game menu for starting a new game or exiting, also accessible at game launch.\n```\n",
    "developed_code": "<PROJECT_NAME_START>ClassicTetrisDesktop<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport random\nimport time\n\n# Define the size of the grid\nGRID_WIDTH = 10\nGRID_HEIGHT = 20\nCELL_SIZE = 30\n\n# Define the size of the window\nWINDOW_WIDTH = GRID_WIDTH * CELL_SIZE\nWINDOW_HEIGHT = GRID_HEIGHT * CELL_SIZE\n\n# Define colors\nWHITE = (255, 255, 255)\nGREY = (128, 128, 128)\nBLACK = (0, 0, 0)\n\n# Define the shapes of the Tetriminos\nSHAPES = [\n    [[1, 1, 1, 1]],  # I\n    [[1, 1, 1], [0, 1, 0]],  # T\n    [[1, 1], [1, 1]],  # O\n    [[0, 1, 1], [1, 1, 0]],  # S\n    [[1, 1, 0], [0, 1, 1]],  # Z\n    [[1, 0, 0], [1, 1, 1]],  # J\n    [[0, 0, 1], [1, 1, 1]]  # L\n]\n\n# Define the colors of the Tetriminos\nSHAPES_COLORS = [\n    (0, 255, 255),  # Cyan\n    (128, 0, 128),  # Purple\n    (255, 255, 0),  # Yellow\n    (0, 255, 0),    # Green\n    (255, 0, 0),    # Red\n    (0, 0, 255),    # Blue\n    (255, 165, 0)   # Orange\n]\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption('Classic Tetris')\n\n# Define the font for displaying the score\nfont = pygame.font.Font(None, 36)\n\n# Define the Tetrimino class\nclass Tetrimino:\n    def __init__(self, shape, color):\n        self.shape = shape\n        self.color = color\n        self.x = GRID_WIDTH // 2 - len(shape[0]) // 2\n        self.y = 0\n        self.rotation = 0\n\n    def rotate(self):\n        self.rotation = (self.rotation + 1) % len(self.shape)\n        self.shape = [list(row) for row in zip(*self.shape[::-1])]\n\n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n\n# Define the game class\nclass TetrisGame:\n    def __init__(self):\n        self.grid = [[0] * GRID_WIDTH for _ in range(GRID_HEIGHT)]\n        self.score = 0\n        self.game_over = False\n        self.current_piece = self.new_piece()\n        self.next_piece = self.new_piece()\n        self.start_time = time.time()\n        self.speed = 1\n\n    def new_piece(self):\n        shape = random.choice(SHAPES)\n        color = SHAPES_COLORS[SHAPES.index(shape)]\n        return Tetrimino(shape, color)\n\n    def collide(self, shape, offset_x, offset_y):\n        for y, row in enumerate(shape):\n            for x, cell in enumerate(row):\n                if cell and (x + offset_x < 0 or x + offset_x >= GRID_WIDTH or y + offset_y >= GRID_HEIGHT or self.grid[y + offset_y][x + offset_x]):\n                    return True\n        return False\n\n    def freeze(self):\n        for y, row in enumerate(self.current_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    self.grid[y + self.current_piece.y][x + self.current_piece.x] = self.current_piece.color\n        self.clear_lines()\n        self.current_piece = self.next_piece\n        self.next_piece = self.new_piece()\n        if self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y):\n            self.game_over = True\n\n    def clear_lines(self):\n        lines_to_clear = [index for index, row in enumerate(self.grid) if all(row)]\n        for index in lines_to_clear:\n            del self.grid[index]\n            self.grid.insert(0, [0] * GRID_WIDTH)\n        self.score += len(lines_to_clear) ** 2\n\n    def move_current_piece(self, dx, dy):\n        if not self.collide(self.current_piece.shape, self.current_piece.x + dx, self.current_piece.y + dy):\n            self.current_piece.move(dx, dy)\n\n    def rotate_current_piece(self):\n        original_shape = self.current_piece.shape\n        self.current_piece.rotate()\n        if self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y):\n            self.current_piece.shape = original_shape\n\n    def drop_current_piece(self):\n        while not self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y + 1):\n            self.current_piece.move(0, 1)\n        self.freeze()\n\n    def update(self):\n        if time.time() - self.start_time > 10:\n            self.speed += 0.1\n            self.start_time = time.time()\n        if not self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y + 1):\n            self.current_piece.move(0, self.speed)\n        else:\n            self.freeze()\n\n    def draw_grid(self):\n        for y in range(GRID_HEIGHT):\n            for x in range(GRID_WIDTH):\n                color = self.grid[y][x]\n                if color:\n                    pygame.draw.rect(screen, color, (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n                pygame.draw.rect(screen, GREY, (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)\n\n    def draw_current_piece(self):\n        for y, row in enumerate(self.current_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    pygame.draw.rect(screen, self.current_piece.color, ((self.current_piece.x + x) * CELL_SIZE, (self.current_piece.y + y) * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def draw_next_piece(self):\n        for y, row in enumerate(self.next_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    pygame.draw.rect(screen, self.next_piece.color, ((GRID_WIDTH + 1 + x) * CELL_SIZE, (1 + y) * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def draw_score(self):\n        score_text = font.render(f'Score: {self.score}', True, WHITE)\n        screen.blit(score_text, (WINDOW_WIDTH - 200, 10))\n\n    def draw_game_over(self):\n        game_over_text = font.render('GAME OVER', True, WHITE)\n        screen.blit(game_over_text, (WINDOW_WIDTH // 2 - game_over_text.get_width() // 2, WINDOW_HEIGHT // 2 - game_over_text.get_height() // 2))\n\n    def draw(self):\n        screen.fill(BLACK)\n        self.draw_grid()\n        self.draw_current_piece()\n        self.draw_next_piece()\n        self.draw_score()\n        if self.game_over:\n            self.draw_game_over()\n        pygame.display.flip()\n\n# Main game loop\ndef main():\n    clock = pygame.time.Clock()\n    game = TetrisGame()\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    game.move_current_piece(-1, 0)\n                elif event.key == pygame.K_RIGHT:\n                    game.move_current_piece(1, 0)\n                elif event.key == pygame.K_UP:\n                    game.rotate_current_piece()\n                elif event.key == pygame.K_DOWN:\n                    game.move_current_piece(0, 1)\n                elif event.key == pygame.K_SPACE:\n                    game.drop_current_piece()\n\n        game.update()\n        game.draw()\n\n        clock.tick(30)\n\n    pygame.quit()\n\nif __name__ == '__main__':\n    main()\n```\n<FILE_END>",
    "finalized_code": "<PROJECT_NAME_START>ClassicTetrisDesktop<PROJECT_NAME_END>\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport random\nimport time\n\n# Define the size of the grid\nGRID_WIDTH = 10\nGRID_HEIGHT = 20\nCELL_SIZE = 30\n\n# Define the size of the window\nWINDOW_WIDTH = GRID_WIDTH * CELL_SIZE\nWINDOW_HEIGHT = GRID_HEIGHT * CELL_SIZE\nNEXT_PIECE_WIDTH = 4 * CELL_SIZE\nNEXT_PIECE_HEIGHT = 4 * CELL_SIZE\nWINDOW_WIDTH_WITH_NEXT = WINDOW_WIDTH + NEXT_PIECE_WIDTH\n\n# Define colors\nWHITE = (255, 255, 255)\nGREY = (128, 128, 128)\nBLACK = (0, 0, 0)\n\n# Define the shapes of the Tetriminos\nSHAPES = [\n    [[1, 1, 1, 1]],  # I\n    [[1, 1, 1], [0, 1, 0]],  # T\n    [[1, 1], [1, 1]],  # O\n    [[0, 1, 1], [1, 1, 0]],  # S\n    [[1, 1, 0], [0, 1, 1]],  # Z\n    [[1, 0, 0], [1, 1, 1]],  # J\n    [[0, 0, 1], [1, 1, 1]]  # L\n]\n\n# Define the colors of the Tetriminos\nSHAPES_COLORS = [\n    (0, 255, 255),  # Cyan\n    (128, 0, 128),  # Purple\n    (255, 255, 0),  # Yellow\n    (0, 255, 0),    # Green\n    (255, 0, 0),    # Red\n    (0, 0, 255),    # Blue\n    (255, 165, 0)   # Orange\n]\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_WIDTH_WITH_NEXT, WINDOW_HEIGHT))\npygame.display.set_caption('Classic Tetris')\n\n# Define the font for displaying the score\nfont = pygame.font.Font(None, 36)\n\n# Define the Tetrimino class\nclass Tetrimino:\n    def __init__(self, shape, color):\n        self.shape = shape\n        self.color = color\n        self.x = GRID_WIDTH // 2 - len(shape[0]) // 2\n        self.y = 0\n        self.rotation = 0\n\n    def rotate(self):\n        self.rotation = (self.rotation + 1) % len(self.shape)\n        self.shape = [list(row) for row in zip(*self.shape[::-1])]\n\n    def move(self, dx, dy):\n        self.x += dx\n        self.y += dy\n\n# Define the game class\nclass TetrisGame:\n    def __init__(self):\n        self.grid = [[0] * GRID_WIDTH for _ in range(GRID_HEIGHT)]\n        self.score = 0\n        self.game_over = False\n        self.current_piece = self.new_piece()\n        self.next_piece = self.new_piece()\n        self.start_time = time.time()\n        self.speed = 1\n        self.level = 1\n\n    def new_piece(self):\n        shape = random.choice(SHAPES)\n        color = SHAPES_COLORS[SHAPES.index(shape)]\n        return Tetrimino(shape, color)\n\n    def collide(self, shape, offset_x, offset_y):\n        for y, row in enumerate(shape):\n            for x, cell in enumerate(row):\n                if cell and (x + offset_x < 0 or x + offset_x >= GRID_WIDTH or y + offset_y >= GRID_HEIGHT or self.grid[y + offset_y][x + offset_x]):\n                    return True\n        return False\n\n    def freeze(self):\n        for y, row in enumerate(self.current_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    self.grid[y + self.current_piece.y][x + self.current_piece.x] = self.current_piece.color\n        self.clear_lines()\n        self.current_piece = self.next_piece\n        self.next_piece = self.new_piece()\n        if self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y):\n            self.game_over = True\n\n    def clear_lines(self):\n        lines_to_clear = [index for index, row in enumerate(self.grid) if all(row)]\n        for index in lines_to_clear:\n            del self.grid[index]\n            self.grid.insert(0, [0] * GRID_WIDTH)\n        self.score += len(lines_to_clear) ** 2\n        if len(lines_to_clear) > 0:\n            self.level += 1\n\n    def move_current_piece(self, dx, dy):\n        if not self.collide(self.current_piece.shape, self.current_piece.x + dx, self.current_piece.y + dy):\n            self.current_piece.move(dx, dy)\n\n    def rotate_current_piece(self):\n        original_shape = self.current_piece.shape\n        self.current_piece.rotate()\n        if self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y):\n            self.current_piece.shape = original_shape\n\n    def drop_current_piece(self):\n        while not self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y + 1):\n            self.current_piece.move(0, 1)\n        self.freeze()\n\n    def update(self):\n        if time.time() - self.start_time > 10:\n            self.speed += 0.1\n            self.start_time = time.time()\n        if not self.collide(self.current_piece.shape, self.current_piece.x, self.current_piece.y + 1):\n            self.current_piece.move(0, self.speed)\n        else:\n            self.freeze()\n\n    def draw_grid(self):\n        for y in range(GRID_HEIGHT):\n            for x in range(GRID_WIDTH):\n                color = self.grid[y][x]\n                if color:\n                    pygame.draw.rect(screen, color, (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n                pygame.draw.rect(screen, GREY, (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)\n\n    def draw_current_piece(self):\n        for y, row in enumerate(self.current_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    pygame.draw.rect(screen, self.current_piece.color, ((self.current_piece.x + x) * CELL_SIZE, (self.current_piece.y + y) * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def draw_next_piece(self):\n        for y, row in enumerate(self.next_piece.shape):\n            for x, cell in enumerate(row):\n                if cell:\n                    pygame.draw.rect(screen, self.next_piece.color, ((GRID_WIDTH + 1 + x) * CELL_SIZE, (1 + y) * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def draw_score(self):\n        score_text = font.render(f'Score: {self.score}', True, WHITE)\n        screen.blit(score_text, (WINDOW_WIDTH - 200, 10))\n\n    def draw_game_over(self):\n        game_over_text = font.render('GAME OVER', True, WHITE)\n        screen.blit(game_over_text, (WINDOW_WIDTH // 2 - game_over_text.get_width() // 2, WINDOW_HEIGHT // 2 - game_over_text.get_height() // 2))\n\n    def draw(self):\n        screen.fill(BLACK)\n        self.draw_grid()\n        self.draw_current_piece()\n        self.draw_next_piece()\n        self.draw_score()\n        if self.game_over:\n            self.draw_game_over()\n        pygame.display.flip()\n\n# Main game loop\ndef main():\n    clock = pygame.time.Clock()\n    game = TetrisGame()\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    game.move_current_piece(-1, 0)\n                elif event.key == pygame.K_RIGHT:\n                    game.move_current_piece(1, 0)\n                elif event.key == pygame.K_UP:\n                    game.rotate_current_piece()\n                elif event.key == pygame.K_DOWN:\n                    game.move_current_piece(0, 1)\n                elif event.key == pygame.K_SPACE:\n                    game.drop_current_piece()\n\n        game.update()\n        game.draw()\n\n        clock.tick(30)\n\n    pygame.quit()\n\nif __name__ == '__main__':\n    main()\n```\n<FILE_END>"
}