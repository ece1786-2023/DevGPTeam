{
    "refine_requirements": "\n# Pixel-art style brick breaker game for adults\n```\n1. Create a main menu with options to start a new game or exit.\n2. Design initial levels with a mix of green bricks and red bricks that contain power-ups.\n3. Implement a level-based progression system with increasing difficulty.\n4. Allow players to control the paddle using keyboard arrow keys or A/D keys, and use the spacebar to launch the ball or pause the game.\n5. Develop a scoring system that awards points for breaking bricks, with a visible score and lives counter.\n6. Activate a power-up that doubles the paddle size and changes the ball color to red for 10 seconds upon breaking a red brick.\n7. Display the game over screen with the final score when all lives are lost, with options to restart or exit.\n8. Ensure realistic ball physics for interactions with the paddle, bricks, and walls.\n9. Players start with 3 lives, with no extra lives mechanism.\n10. Exclude a high score table unless later requested by the client.\n```\n",
    "developed_code": "<PROJECT_NAME_START>PixelBreaker<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport sys\nimport random\n\n# Constants\nSCREEN_WIDTH = 800\nSCREEN_HEIGHT = 600\nBRICK_WIDTH = 60\nBRICK_HEIGHT = 20\nPADDLE_WIDTH = 100\nPADDLE_HEIGHT = 20\nBALL_RADIUS = 10\nBRICK_ROWS = 6\nBRICK_COLUMNS = 10\nBRICK_SPACING = 5\nLIVES = 3\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nDARK_RED = (139, 0, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Set up the screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\npygame.display.set_caption(\"PixelBreaker\")\n\n# Set up the font\nfont = pygame.font.Font(None, 36)\n\n# Game variables\nscore = 0\nlives = LIVES\nball_speed_x = 4 * random.choice((1, -1))\nball_speed_y = -4\npaddle_speed = 0\npower_up_active = False\npower_up_timer = 0\n\n# Paddle\npaddle = pygame.Rect(SCREEN_WIDTH // 2 - PADDLE_WIDTH // 2, SCREEN_HEIGHT - 40, PADDLE_WIDTH, PADDLE_HEIGHT)\n\n# Ball\nball = pygame.Rect(SCREEN_WIDTH // 2 - BALL_RADIUS, paddle.y - BALL_RADIUS * 2, BALL_RADIUS * 2, BALL_RADIUS * 2)\n\n# Bricks\nbricks = []\nfor row in range(BRICK_ROWS):\n    brick_color = GREEN if row % 2 == 0 else RED\n    for column in range(BRICK_COLUMNS):\n        brick = pygame.Rect(column * (BRICK_WIDTH + BRICK_SPACING) + BRICK_SPACING,\n                            row * (BRICK_HEIGHT + BRICK_SPACING) + BRICK_SPACING + 50,\n                            BRICK_WIDTH,\n                            BRICK_HEIGHT)\n        bricks.append((brick, brick_color))\n\n# Main menu\ndef main_menu():\n    while True:\n        screen.fill(BLACK)\n        title_text = font.render(\"PixelBreaker\", True, WHITE)\n        start_text = font.render(\"Press SPACE to start\", True, WHITE)\n        quit_text = font.render(\"Press ESC to quit\", True, WHITE)\n\n        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))\n        start_rect = start_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))\n        quit_rect = quit_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))\n\n        screen.blit(title_text, title_rect)\n        screen.blit(start_text, start_rect)\n        screen.blit(quit_text, quit_rect)\n\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    return\n                if event.key == pygame.K_ESCAPE:\n                    pygame.quit()\n                    sys.exit()\n\n# Game over screen\ndef game_over():\n    while True:\n        screen.fill(BLACK)\n        game_over_text = font.render(\"Game Over\", True, WHITE)\n        final_score_text = font.render(f\"Final Score: {score}\", True, WHITE)\n        restart_text = font.render(\"Press SPACE to restart\", True, WHITE)\n        quit_text = font.render(\"Press ESC to quit\", True, WHITE)\n\n        game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))\n        final_score_rect = final_score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))\n        restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))\n        quit_rect = quit_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))\n\n        screen.blit(game_over_text, game_over_rect)\n        screen.blit(final_score_text, final_score_rect)\n        screen.blit(restart_text, restart_rect)\n        screen.blit(quit_text, quit_rect)\n\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    reset_game()\n                    return\n                if event.key == pygame.K_ESCAPE:\n                    pygame.quit()\n                    sys.exit()\n\n# Reset game\ndef reset_game():\n    global score, lives, ball_speed_x, ball_speed_y, paddle, ball, bricks, power_up_active, power_up_timer\n    score = 0\n    lives = LIVES\n    ball_speed_x = 4 * random.choice((1, -1))\n    ball_speed_y = -4\n    paddle = pygame.Rect(SCREEN_WIDTH // 2 - PADDLE_WIDTH // 2, SCREEN_HEIGHT - 40, PADDLE_WIDTH, PADDLE_HEIGHT)\n    ball = pygame.Rect(SCREEN_WIDTH // 2 - BALL_RADIUS, paddle.y - BALL_RADIUS * 2, BALL_RADIUS * 2, BALL_RADIUS * 2)\n    bricks = []\n    for row in range(BRICK_ROWS):\n        brick_color = GREEN if row % 2 == 0 else RED\n        for column in range(BRICK_COLUMNS):\n            brick = pygame.Rect(column * (BRICK_WIDTH + BRICK_SPACING) + BRICK_SPACING,\n                                row * (BRICK_HEIGHT + BRICK_SPACING) + BRICK_SPACING + 50,\n                                BRICK_WIDTH,\n                                BRICK_HEIGHT)\n            bricks.append((brick, brick_color))\n    power_up_active = False\n    power_up_timer = 0\n\n# Main game loop\ndef main_game():\n    global score, lives, ball_speed_x, ball_speed_y, paddle_speed, power_up_active, power_up_timer\n\n    clock = pygame.time.Clock()\n    running = True\n    ball_launched = False\n\n    while running:\n        screen.fill(BLACK)\n\n        # Event handling\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT or event.key == pygame.K_a:\n                    paddle_speed = -6\n                if event.key == pygame.K_RIGHT or event.key == pygame.K_d:\n                    paddle_speed = 6\n                if event.key == pygame.K_SPACE:\n                    if not ball_launched:\n                        ball_launched = True\n                    else:\n                        # Pause functionality\n                        paused = True\n                        while paused:\n                            for pause_event in pygame.event.get():\n                                if pause_event.type == pygame.KEYDOWN and pause_event.key == pygame.K_SPACE:\n                                    paused = False\n                                if pause_event.type == pygame.QUIT:\n                                    pygame.quit()\n                                    sys.exit()\n            if event.type == pygame.KEYUP:\n                if event.key == pygame.K_LEFT or event.key == pygame.K_a or event.key == pygame.K_RIGHT or event.key == pygame.K_d:\n                    paddle_speed = 0\n\n        # Paddle movement\n        paddle.x += paddle_speed\n        if paddle.left < 0:\n            paddle.left = 0\n        if paddle.right > SCREEN_WIDTH:\n            paddle.right = SCREEN_WIDTH\n\n        # Ball movement\n        if ball_launched:\n            ball.x += ball_speed_x\n            ball.y += ball_speed_y\n\n            # Ball collision with walls\n            if ball.left <= 0 or ball.right >= SCREEN_WIDTH:\n                ball_speed_x *= -1\n            if ball.top <= 0:\n                ball_speed_y *= -1\n            if ball.bottom >= SCREEN_HEIGHT:\n                lives -= 1\n                ball_launched = False\n                ball.center = (SCREEN_WIDTH // 2, paddle.y - BALL_RADIUS * 2)\n                ball_speed_x = 4 * random.choice((1, -1))\n                ball_speed_y = -4\n                if lives == 0:\n                    game_over()\n                    running = False\n\n            # Ball collision with paddle\n            if ball.colliderect(paddle) and ball_speed_y > 0:\n                ball_speed_y *= -1\n                offset = (ball.centerx - paddle.centerx) / (paddle.width / 2)\n                ball_speed_x += offset * 2\n\n            # Ball collision with bricks\n            for brick, color in bricks[:]:\n                if ball.colliderect(brick):\n                    if color == GREEN:\n                        score += 5\n                    elif color == RED:\n                        score += 10\n                        power_up_active = True\n                        power_up_timer = pygame.time.get_ticks()\n                        ball_speed_x *= 1.5\n                        ball_speed_y *= 1.5\n                        ball.color = DARK_RED\n                    bricks.remove((brick, color))\n                    ball_speed_y *= -1\n                    break\n\n        # Power-up logic\n        if power_up_active:\n            current_time = pygame.time.get_ticks()\n            if current_time - power_up_timer > 10000:\n                power_up_active = False\n                paddle.width = PADDLE_WIDTH\n                ball.color = BLUE\n                ball_speed_x /= 1.5\n                ball_speed_y /= 1.5\n            else:\n                paddle.width = PADDLE_WIDTH * 2\n\n        # Draw everything\n        pygame.draw.rect(screen, WHITE, paddle)\n        pygame.draw.ellipse(screen, ball.color, ball)\n        for brick, color in bricks:\n            pygame.draw.rect(screen, color, brick)\n\n        # Draw the score and lives\n        score_text = font.render(f\"Score: {score}\", True, WHITE)\n        lives_text = font.render(f\"Lives: {lives}\", True, WHITE)\n        screen.blit(score_text, (5, 5))\n        screen.blit(lives_text, (SCREEN_WIDTH - lives_text.get_width() - 5, 5))\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n# Start the game\nmain_menu()\nmain_game()\n```\n<FILE_END>",
    "finalized_code": "<PROJECT_NAME_START>PixelBreaker<PROJECT_NAME_END>\n\n<FILE_START>\nmain.py\n```python\nimport pygame\nimport sys\nimport random\n\n# Constants\nSCREEN_WIDTH = 800\nSCREEN_HEIGHT = 600\nBRICK_WIDTH = 60\nBRICK_HEIGHT = 20\nPADDLE_WIDTH = 100\nPADDLE_HEIGHT = 20\nBALL_RADIUS = 10\nBRICK_ROWS = 6\nBRICK_COLUMNS = 10\nBRICK_SPACING = 5\nLIVES = 3\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nDARK_RED = (139, 0, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Set up the screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\npygame.display.set_caption(\"PixelBreaker\")\n\n# Set up the font\nfont = pygame.font.Font(None, 36)\n\n# Game variables\nscore = 0\nlives = LIVES\nball_speed_x = 4 * random.choice((1, -1))\nball_speed_y = -4\npaddle_speed = 0\npower_up_active = False\npower_up_timer = 0\n\n# Paddle\npaddle = pygame.Rect(SCREEN_WIDTH // 2 - PADDLE_WIDTH // 2, SCREEN_HEIGHT - 40, PADDLE_WIDTH, PADDLE_HEIGHT)\n\n# Ball\nball = pygame.Rect(SCREEN_WIDTH // 2 - BALL_RADIUS, paddle.y - BALL_RADIUS * 2, BALL_RADIUS * 2, BALL_RADIUS * 2)\nball_color = BLUE  # Initialize ball color\n\n# Bricks\nbricks = []\nfor row in range(BRICK_ROWS):\n    brick_color = GREEN if row % 2 == 0 else RED\n    for column in range(BRICK_COLUMNS):\n        brick = pygame.Rect(column * (BRICK_WIDTH + BRICK_SPACING) + BRICK_SPACING,\n                            row * (BRICK_HEIGHT + BRICK_SPACING) + BRICK_SPACING + 50,\n                            BRICK_WIDTH,\n                            BRICK_HEIGHT)\n        bricks.append((brick, brick_color))\n\n# Main menu\ndef main_menu():\n    while True:\n        screen.fill(BLACK)\n        title_text = font.render(\"PixelBreaker\", True, WHITE)\n        start_text = font.render(\"Press SPACE to start\", True, WHITE)\n        quit_text = font.render(\"Press ESC to quit\", True, WHITE)\n\n        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))\n        start_rect = start_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))\n        quit_rect = quit_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))\n\n        screen.blit(title_text, title_rect)\n        screen.blit(start_text, start_rect)\n        screen.blit(quit_text, quit_rect)\n\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    return\n                if event.key == pygame.K_ESCAPE:\n                    pygame.quit()\n                    sys.exit()\n\n# Game over screen\ndef game_over():\n    while True:\n        screen.fill(BLACK)\n        game_over_text = font.render(\"Game Over\", True, WHITE)\n        final_score_text = font.render(f\"Final Score: {score}\", True, WHITE)\n        restart_text = font.render(\"Press SPACE to restart\", True, WHITE)\n        quit_text = font.render(\"Press ESC to quit\", True, WHITE)\n\n        game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))\n        final_score_rect = final_score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))\n        restart_rect = restart_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))\n        quit_rect = quit_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))\n\n        screen.blit(game_over_text, game_over_rect)\n        screen.blit(final_score_text, final_score_rect)\n        screen.blit(restart_text, restart_rect)\n        screen.blit(quit_text, quit_rect)\n\n        pygame.display.flip()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    reset_game()\n                    return\n                if event.key == pygame.K_ESCAPE:\n                    pygame.quit()\n                    sys.exit()\n\n# Reset game\ndef reset_game():\n    global score, lives, ball_speed_x, ball_speed_y, paddle, ball, bricks, power_up_active, power_up_timer, ball_color\n    score = 0\n    lives = LIVES\n    ball_speed_x = 4 * random.choice((1, -1))\n    ball_speed_y = -4\n    paddle = pygame.Rect(SCREEN_WIDTH // 2 - PADDLE_WIDTH // 2, SCREEN_HEIGHT - 40, PADDLE_WIDTH, PADDLE_HEIGHT)\n    ball = pygame.Rect(SCREEN_WIDTH // 2 - BALL_RADIUS, paddle.y - BALL_RADIUS * 2, BALL_RADIUS * 2, BALL_RADIUS * 2)\n    ball_color = BLUE\n    bricks = []\n    for row in range(BRICK_ROWS):\n        brick_color = GREEN if row % 2 == 0 else RED\n        for column in range(BRICK_COLUMNS):\n            brick = pygame.Rect(column * (BRICK_WIDTH + BRICK_SPACING) + BRICK_SPACING,\n                                row * (BRICK_HEIGHT + BRICK_SPACING) + BRICK_SPACING + 50,\n                                BRICK_WIDTH,\n                                BRICK_HEIGHT)\n            bricks.append((brick, brick_color))\n    power_up_active = False\n    power_up_timer = 0\n\n# Main game loop\ndef main_game():\n    global score, lives, ball_speed_x, ball_speed_y, paddle_speed, power_up_active, power_up_timer, ball_color\n\n    clock = pygame.time.Clock()\n    running = True\n    ball_launched = False\n\n    while running:\n        screen.fill(BLACK)\n\n        # Event handling\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT or event.key == pygame.K_a:\n                    paddle_speed = -6\n                if event.key == pygame.K_RIGHT or event.key == pygame.K_d:\n                    paddle_speed = 6\n                if event.key == pygame.K_SPACE:\n                    if not ball_launched:\n                        ball_launched = True\n                    else:\n                        # Pause functionality\n                        paused = True\n                        while paused:\n                            for pause_event in pygame.event.get():\n                                if pause_event.type == pygame.KEYDOWN and pause_event.key == pygame.K_SPACE:\n                                    paused = False\n                                if pause_event.type == pygame.QUIT:\n                                    pygame.quit()\n                                    sys.exit()\n            if event.type == pygame.KEYUP:\n                if event.key == pygame.K_LEFT or event.key == pygame.K_a or event.key == pygame.K_RIGHT or event.key == pygame.K_d:\n                    paddle_speed = 0\n\n        # Paddle movement\n        paddle.x += paddle_speed\n        if paddle.left < 0:\n            paddle.left = 0\n        if paddle.right > SCREEN_WIDTH:\n            paddle.right = SCREEN_WIDTH\n\n        # Ball movement\n        if ball_launched:\n            ball.x += ball_speed_x\n            ball.y += ball_speed_y\n\n            # Ball collision with walls\n            if ball.left <= 0 or ball.right >= SCREEN_WIDTH:\n                ball_speed_x *= -1\n            if ball.top <= 0:\n                ball_speed_y *= -1\n            if ball.bottom >= SCREEN_HEIGHT:\n                lives -= 1\n                ball_launched = False\n                ball.center = (SCREEN_WIDTH // 2, paddle.y - BALL_RADIUS * 2)\n                ball_speed_x = 4 * random.choice((1, -1))\n                ball_speed_y = -4\n                if lives == 0:\n                    game_over()\n                    running = False\n\n            # Ball collision with paddle\n            if ball.colliderect(paddle) and ball_speed_y > 0:\n                ball_speed_y *= -1\n                offset = (ball.centerx - paddle.centerx) / (paddle.width / 2)\n                ball_speed_x += offset * 2\n\n            # Ball collision with bricks\n            for brick, color in bricks[:]:\n                if ball.colliderect(brick):\n                    if color == GREEN:\n                        score += 5\n                    elif color == RED:\n                        score += 10\n                        if not power_up_active:  # Only activate power-up if not already active\n                            power_up_active = True\n                            power_up_timer = pygame.time.get_ticks()\n                            ball_color = DARK_RED\n                    bricks.remove((brick, color))\n                    ball_speed_y *= -1\n                    break\n\n        # Power-up logic\n        if power_up_active:\n            current_time = pygame.time.get_ticks()\n            if current_time - power_up_timer > 10000:\n                power_up_active = False\n                paddle.width = PADDLE_WIDTH\n                ball_color = BLUE\n            else:\n                paddle.width = PADDLE_WIDTH * 2\n\n        # Draw everything\n        pygame.draw.rect(screen, WHITE, paddle)\n        pygame.draw.ellipse(screen, ball_color, ball)\n        for brick, color in bricks:\n            pygame.draw.rect(screen, color, brick)\n\n        # Draw the score and lives\n        score_text = font.render(f\"Score: {score}\", True, WHITE)\n        lives_text = font.render(f\"Lives: {lives}\", True, WHITE)\n        screen.blit(score_text, (5, 5))\n        screen.blit(lives_text, (SCREEN_WIDTH - lives_text.get_width() - 5, 5))\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n# Start the game\nmain_menu()\nmain_game()\n```\n<FILE_END>"
}